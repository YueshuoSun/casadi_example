/**
 * @file casadi_example.cc
 * @brief 使用 CasADi C++ API 求解一个基本的非线性规划（NLP）问题。
 * @author Yueshuo Sun
 *
 * 本示例演示了如何定义一个优化问题，包括决策变量、目标函数和约束，
 * 并使用 IPOPT 求解器来找到最优解。
 *
 * 待求解的优化问题如下:
 * minimize(x,y,z)   f(x, z) = x^2 + 100*z^2
 * subject to        g(x, y, z) = z + (1-x)^2 - y = 0
 */

#include <casadi/casadi.hpp>
#include <iostream>

using namespace casadi;

int main() {
    // --------------------------------------------------------------------------
    // 1. 定义问题：创建符号变量
    // --------------------------------------------------------------------------
    MX x = MX::sym("x");
    MX y = MX::sym("y");
    MX z = MX::sym("z");

    // --------------------------------------------------------------------------
    // 2. 构建表达式：目标函数与约束
    // --------------------------------------------------------------------------
    // 目标函数: f = x^2 + 100*z^2
    MX f = pow(x, 2) + 100 * pow(z, 2);
    // 约束函数: g = z + (1-x)^2 - y
    MX g = z + pow(1 - x, 2) - y;

    // --------------------------------------------------------------------------
    // 3. 组装非线性规划 (NLP) 问题
    // --------------------------------------------------------------------------
    MXDict nlp_problem;
    // "x": 定义问题的决策变量。
    nlp_problem["x"] = vertcat(x, y, z);
    // "f": 定义目标函数。
    nlp_problem["f"] = f;
    // "g": 定义约束函数。
    nlp_problem["g"] = g;

    // --------------------------------------------------------------------------
    // 4. 配置并创建求解器
    // --------------------------------------------------------------------------
    // 创建一个字典来存放 IPOPT 求解器的特定选项。
    Dict solver_options;
    // 'ipopt.linear_solver' 选项决定了 IPOPT 内部算法使用的线性求解器。
    solver_options["ipopt.linear_solver"] = "ma27";
    // 控制台输出详细程度。
    solver_options["ipopt.print_level"] = 5;
    // `nlpsol` 用于创建一个 NLP 求解器实例。
    Function solver = nlpsol("solver", "ipopt", nlp_problem, solver_options);

    // --------------------------------------------------------------------------
    // 5. 求解问题
    // --------------------------------------------------------------------------
    // 为求解过程提供具体的数值输入。
    DMDict solver_arguments;
    // 为决策变量提供初始猜测值 (x0)。一个好的初始猜测可以显著提高收敛速度。
    solver_arguments["x0"] = DM({2.5, 3.0, 0.75});
    // 设置约束 g(x,y,z) 的上下界 (lbg 和 ubg)。
    // 因为我们的约束是等式约束 g = 0，所以其下界和上界都设置为 0。
    solver_arguments["lbg"] = 0;
    solver_arguments["ubg"] = 0;
    // 调用求解器并传入参数，返回包含结果的字典。
    DMDict solution = solver(solver_arguments);

    // --------------------------------------------------------------------------
    // 6. 提取并打印结果
    // --------------------------------------------------------------------------
    // 从返回的结果字典中提取最优解和对应的目标函数值。
    DM optimal_x = solution.at("x");
    DM optimal_f = solution.at("f");
    std::cout << "--------------------------------" << std::endl;
    std::cout << "求解完成." << std::endl;
    std::cout << "最优解 (x, y, z): " << optimal_x << std::endl;
    std::cout << "最优目标值: " << optimal_f << std::endl;
    std::cout << "--------------------------------" << std::endl;

    return 0;
}
